Сначала приколюха: пустая структура/класс занимает 1 байт в памяти, потому что это минимум, сколько может занимать объект, потому что у разных объектов должны быть разные адреса. Если бы sizeof пустой структуры был бы 0, то мы могли бы объявить массив таких структур размера 100, и этот бы массив тоже имел бы размер 0, и тогда получается, что адрес начала и конца этого массива ничем бы не отличались. Крч кринж какой-то, адреса разных объектов должны быть разными, мы должны уметь отличать объекты по их адресам.

Например, в операторе присваивания мы бы не смогли проверить, что мы присваиваем самим себе. Т.е. если бы у нас не было правила, что не бывает объектов размера 0, то эта проверка могла бы некорректно работать в случае объектов размера 0.

C++ гарантирует нам, что у разных объектов разные адреса

Ну а в таком случае у нас размеры 1 и 8 соответственно

    #include <iostream>

    struct Base{
        void f() {}
    };

    struct Derived : Base{
        double y;
        void g() {}
    };

    int main(){
        std::cout << sizeof(Base) << std::endl;
        std::cout << sizeof(Derived) << std::endl;
    }

# Приведение типов при наследовании
Рассмотрим пример:

    #include <iostream>

    struct Base{
        int x = 1;
    };

    struct Derived : Base{
        int y = 2;
    };

    void f(Base& b){
        std::cout << b.x << std::endl;
    }


    int main(){
        Derived d;
        f(d);
    }
Ключевая идея наследования в том, что вот так можно делать: если у нас есть наследник, а функция принимает родителя, то ей можно подсунуть наследника вместо родителя, и все будет прекрасно работать.
Вся идея наследования в том, чтобы можно было так делать, чтобы можно было использовать наследника там, где ожидается родитель, потому что наследник умеет все то же, что и родитель, и возможно что-то еще.

Это напоминает const и не const: когда мы в функции принимаем что-то по константной ссылке, то мы туда можем отдать как константу, так и не константу, потому что константа - это просто тип, у которого убрана часть операций. То же самое и с наследованием. В обратную сторону будет CE.

Мы можем даже по значению передавать Derived там где ожидается Base. И в этой ситуации произойдет явление, которое называется **slicing** (срезка при копировании). Будет неявно сгенерирован конструктор Base у Derived, который просто заберет ту часть, которая относилась к Base и все. Также можно даже передавать по указателю.

Представим, что у Base нетривиальный конструктор копирования:

    #include <iostream>

    struct Base{
        int x = 1;
        Base(const Base& other)
        : x(other.x) { 
            std::cout << "Copy!" << std::endl; 
        }
    };


    struct Derived : Base{
        int y = 2;
    };

    void f(Base b){
        std::cout << b.x << std::endl;
    }


    int main(){
        Derived d;
        f(d);
    }
*Т.к. мы у Base определили конструктор копирования, то дефолтный конструктор у него тоже пропал*

В данном коде у нас выведется:

    Copy!
    1

---

У нас есть Base и Derived, и нас интересует следующее: сможем ли мы скастовать Base к Derived, Derived& и т.д.
![alt text](images/1.png)

Почему possibly UB? Если мы отдали указатель или ссылку на Base туда, где ожидался Derived, то это конечно скомпилируется, но если реально под этой ссылкой был Base, а не Derived, то при попытке обращения к полям и методам Derived будет UB.

Но это только для public наследования. Для private наследования иначе: приватное наследование идейно означает, что если мы не член класса и не друг, то в этой функции нам недоступен тот факт, что Derived это на самом деле Base.
![alt text](images/2.png)

Если наследование protected, то это так же, как и при приватном, просто в зависимости от того, где мы находимся, теперь нам можно еще это делать в методах наследника, а не только в методах исходного класса.

# Multiple inheritance
Не везде разрешено множественное наследование. А что плохого в нем? 
## Первая проблема
Главная проблема множественного наследования: что будет, если мы несколько раз наследуемся от одного и того же через разных промежуточных родителей?
![alt text](images/3.png)

Как это будет располагаться в памяти? Сначала в память кладутся родители, затем сын, причем в том порядке, в котором мы их перечислили
![alt text](images/4.png)

Есть вопросик: у нас есть функция

    void f(Dad&);
Можем ли мы в такую функцию отдать сына? По-идее можем, ведь сын - это частный случай папы, все ок. Но как, если адрес папы не такой, как адрес сына? Подобъект папы в этом объекте начинается с адреса на 4 большего, чем сам объект исходный. Т.е. получается, что когда мы пытаемся отдать в функцию сына по ссылке на папу, то неявный каст должен сдвинуть адрес чтоли? Ладно, хер с ней с ссылкой, а что с указателем? 

    void f(Dad*);
Т.е. если мы берем адрес сына и превращаем его неявно в адрес папы, то указатель должен сдвинуться на 4?

Конечно же надо будет сдвинуть указатель на 4. При неявных кастах иногда разрешается изменение численного значения указателя. То же самое и с
    
    Dad* p = &s;

В стандартной библиотеке есть множественное наследование, например в [iostream](https://en.cppreference.com/w/cpp/io/basic_iostream) - он одновременно наследник и istream, и ostream

## Вторая проблема
Что будет, если поля или методы называются одинаково
![alt text](images/5.png)
Если мы в сыне объявим метод, который затмевает по названию эти методы, то туда поиск имен уже не пойдет. Но если в сыне мы не объявили метод, а в маме и папе был метод с одинаковыми названиями, причем необязательно с одинаковыми аргументами, то будет перегрузка между ними. Т.е. если мы пишем s.f() от чего-то, то методы мамы и методы папы для нас равноправные, и компилятор просто делает перегрузку между ними уже: все эти методы попадают в множество, из которого делается перегрузка.

Если мы унаследовали два одинаковых метода, то это все еще не CE, но если мы вызвали s.f(), то будет CE.

Но мы можем явно сказать, к кому хотим обратиться:

    s.Dad::f();

// TODO
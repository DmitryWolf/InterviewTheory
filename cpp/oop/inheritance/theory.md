Сначала приколюха: пустая структура/класс занимает 1 байт в памяти, потому что это минимум, сколько может занимать объект, потому что у разных объектов должны быть разные адреса. Если бы sizeof пустой структуры был бы 0, то мы могли бы объявить массив таких структур размера 100, и этот бы массив тоже имел бы размер 0, и тогда получается, что адрес начала и конца этого массива ничем бы не отличались. Крч кринж какой-то, адреса разных объектов должны быть разными, мы должны уметь отличать объекты по их адресам.

Например, в операторе присваивания мы бы не смогли проверить, что мы присваиваем самим себе. Т.е. если бы у нас не было правила, что не бывает объектов размера 0, то эта проверка могла бы некорректно работать в случае объектов размера 0.

C++ гарантирует нам, что у разных объектов разные адреса

Ну а в таком случае у нас размеры 1 и 8 соответственно

    #include <iostream>

    struct Base{
        void f() {}
    };

    struct Derived : Base{
        double y;
        void g() {}
    };

    int main(){
        std::cout << sizeof(Base) << std::endl;
        std::cout << sizeof(Derived) << std::endl;
    }

# Приведение типов при наследовании
Рассмотрим пример:

    #include <iostream>

    struct Base{
        int x = 1;
    };

    struct Derived : Base{
        int y = 2;
    };

    void f(Base& b){
        std::cout << b.x << std::endl;
    }


    int main(){
        Derived d;
        f(d);
    }
Ключевая идея наследования в том, что вот так можно делать: если у нас есть наследник, а функция принимает родителя, то ей можно подсунуть наследника вместо родителя, и все будет прекрасно работать.
Вся идея наследования в том, чтобы можно было так делать, чтобы можно было использовать наследника там, где ожидается родитель, потому что наследник умеет все то же, что и родитель, и возможно что-то еще.

Это напоминает const и не const: когда мы в функции принимаем что-то по константной ссылке, то мы туда можем отдать как константу, так и не константу, потому что константа - это просто тип, у которого убрана часть операций. То же самое и с наследованием. В обратную сторону будет CE.

Мы можем даже по значению передавать Derived там где ожидается Base. И в этой ситуации произойдет явление, которое называется **slicing** (срезка при копировании). Будет неявно сгенерирован конструктор Base у Derived, который просто заберет ту часть, которая относилась к Base и все. Также можно даже передавать по указателю.

Представим, что у Base нетривиальный конструктор копирования:

    #include <iostream>

    struct Base{
        int x = 1;
        Base(const Base& other)
        : x(other.x) { 
            std::cout << "Copy!" << std::endl; 
        }
    };


    struct Derived : Base{
        int y = 2;
    };

    void f(Base b){
        std::cout << b.x << std::endl;
    }


    int main(){
        Derived d;
        f(d);
    }
*Т.к. мы у Base определили конструктор копирования, то дефолтный конструктор у него тоже пропал*

В данном коде у нас выведется:

    Copy!
    1

---

У нас есть Base и Derived, и нас интересует следующее: сможем ли мы скастовать Base к Derived, Derived& и т.д.
![alt text](images/1.png)

Почему possibly UB? Если мы отдали указатель или ссылку на Base туда, где ожидался Derived, то это конечно скомпилируется, но если реально под этой ссылкой был Base, а не Derived, то при попытке обращения к полям и методам Derived будет UB.

Но это только для public наследования. Для private наследования иначе: приватное наследование идейно означает, что если мы не член класса и не друг, то в этой функции нам недоступен тот факт, что Derived это на самом деле Base.
![alt text](images/2.png)

Если наследование protected, то это так же, как и при приватном, просто в зависимости от того, где мы находимся, теперь нам можно еще это делать в методах наследника, а не только в методах исходного класса.

# Multiple inheritance
Не везде разрешено множественное наследование. А что плохого в нем? 
## Первая проблема
Главная проблема множественного наследования: что будет, если мы несколько раз наследуемся от одного и того же через разных промежуточных родителей?
![alt text](images/3.png)

Как это будет располагаться в памяти? Сначала в память кладутся родители, затем сын, причем в том порядке, в котором мы их перечислили
![alt text](images/4.png)

Есть вопросик: у нас есть функция

    void f(Dad&);
Можем ли мы в такую функцию отдать сына? По-идее можем, ведь сын - это частный случай папы, все ок. Но как, если адрес папы не такой, как адрес сына? Подобъект папы в этом объекте начинается с адреса на 4 большего, чем сам объект исходный. Т.е. получается, что когда мы пытаемся отдать в функцию сына по ссылке на папу, то неявный каст должен сдвинуть адрес чтоли? Ладно, хер с ней с ссылкой, а что с указателем? 

    void f(Dad*);
Т.е. если мы берем адрес сына и превращаем его неявно в адрес папы, то указатель должен сдвинуться на 4?

Конечно же надо будет сдвинуть указатель на 4. При неявных кастах иногда разрешается изменение численного значения указателя. То же самое и с
    
    Dad* p = &s;

В стандартной библиотеке есть множественное наследование, например в [iostream](https://en.cppreference.com/w/cpp/io/basic_iostream) - он одновременно наследник и istream, и ostream

## Вторая проблема
Что будет, если поля или методы называются одинаково
![alt text](images/5.png)
Если мы в сыне объявим метод, который затмевает по названию эти методы, то туда поиск имен уже не пойдет. Но если в сыне мы не объявили метод, а в маме и папе был метод с одинаковыми названиями, причем необязательно с одинаковыми аргументами, то будет перегрузка между ними. Т.е. если мы пишем s.f() от чего-то, то методы мамы и методы папы для нас равноправные, и компилятор просто делает перегрузку между ними уже: все эти методы попадают в множество, из которого делается перегрузка.

Если мы унаследовали два одинаковых метода, то это все еще не CE, но если мы вызвали s.f(), то будет CE.

Но мы можем явно сказать, к кому хотим обратиться:

    s.Dad::f();

Примечание: сдвиг указателя происходит, если мы кастуем себя к тому родителю, который не первый.

## Diamond problem (ромбовидное наследование)
Самое интересное происходит, если у нас есть Mom, Dad, Granny, Son, где Mom Dad наследуются от Granny, а Son наследуется от Mom и Dad.
![alt text](images/6.png)

    struct Granny {
        int g = 0;
    };
    struct Mom : public Granny {
        int m = 1;
    };

    struct Dad : public Granny {
        int d = 2;
    };
    struct Son : public Mom, public Dad {
        int s = 3;
    };
При этом sizeof(Son) это 20 байт.

В памяти у нас будет две копии Granny:
![alt text](images/7.png)

Если мы напишем 
    
    s.g;
то будет ошибка CE из-за неоднозначность (ambiguous name), потому что есть два поля с именем g в сыне: одно от мамы, одно от папы. При этом приватность не как не влияет на поиск имен: все то, что было выше в конспектах (и будет ниже), никак не меняется от приватности, т.е. когда здесь все срабатывает, то только тогда надо смотреть на приватность. Поиск имен, выбор версии перегрузки никак не зависит от приватности: ни от приватности наследование, ни от приватности полей или методов. Поэтому все равно будет неоднозначность, даже если одна бабушка приватная и одна публичная.

Но мы можем сказать

    s.Mom::g;
но мы не можем сказать

    s.Granny::g;
будет CE, потому что это будет неоднозначность, потому что Granny неоднозначно.

Попробуем сделать каст к Granny

    Granny& g = s;
будет CE по причине **ambiguous cast**. Можно понять это как каст к первой бабушке, а можно понять как каст ко второй бабушке, и непонятно к какой. То же самое будет при касте указателя, при попытке сделать слайсинг, при статик касте - это неважно.

Но как сделать каст к бабушке? Если напишем

    static_cast<Mom::Granny&>(s);
то все равно получим CE, потому что Granny которая в Mom, и Granny которая просто - это один и тот же тип с точки зрения эквивалентности типов, и для static_cast важно, какой это тип, и поэтому это тоже CE, все равно неоднозначный каст, потому что внутри мамы Granny не означает ничего иного, вот если бы внутри мамы был объявлен еще внутренний класс Granny, и это было бы что-то иное по сравнению с обычной Granny, то тогда это бы на что-то влияло, но так это не влияет. Поэтому нам нужно сначала скастить к Mom/Dad, и только затем к Granny.

---
Следующий пример: представим, что у нас в Granny есть метод f, и мы пишем 
    
    s.f();
Что может пойти не так? Если f - это метод бабушки, то это точно неоднозначно, если он не переопределен где-либо.

Но в чем неоднозначность, если метод один и тот же? Метод то один и тот же, но он может пользоваться полями, а поля зависят от того, от какой бабушки мы вызвались. Поэтому этот метод можно двояко понять.

*Замечание: если напишем static void f() , то все заработает:*

    #include <iostream>

    struct Granny {
        int g = 0;
        static void f(){
            std::cout << "static void f in Granny!" << std::endl;
        }
    };
    struct Mom : public Granny {
        int m = 1;
    };

    struct Dad : public Granny {
        int d = 2;
    };
    struct Son : public Mom, public Dad {
        int s = 3;
    };

    int main(){
        Son s;
        s.f();
        return 0;
    }

---
Разберем еще один пример:

    Mom& m = s;
    static_cast<Dad&>(m);
будет ли это работать? По факту под этой ссылкой лежит сын, поэтому теоретически можно было бы взять и сдвинуть указатель на 4, и там бы папа оказался, т.е. можно было разрешить такой каст в теории. Но такой каст запрещен: это CE. На самом деле даже теоретически такой каст нельзя позволить. Допустим, у нас есть класс Daughter, у которого первый родитель это Dad, а второй это Mom, и в зависимости от того, какой у нас объект под нами на самом деле, нам нужно делать либо сдвиг вправо делать, либо сдвиг влево, и вообще сдвиг неизвестно насколько нам нужно делать. Поэтому такой каст нельзя разрешить. Т.е. static_cast вбок запрещен.

Вдобавок к этому, каст от бабушки к сыну вниз тоже неопределен, потому что непонятно, от какой именно бабушки, т.е. если бы у нас был static_cast от Granny к Son, но при этом она была бы его единственной бабушкой, то понятно, как это работает, потому что статик касту понятно, какой сдвиг сделать при касте. Но если у нас static_cast от Granny к Son, и бабушек две, то статик касту непонятно, какой бабушкой себя считать на данный момент. Но можно от Granny к Dad/Mom, а затем к Son

---
Новый пример: представим, что мы унаследовались от Dad, которая наследница Granny, а еще мы унаследовались напрямую от Granny
![alt text](images/8.png)
Как нам обратиться к полю Granny? Если мы напишем 

    s.Granny::g;
то это будет неоднозначность, потому что бабушек две, и прямая Granny никак не приоритетнее, нежели Granny у Dad.

Такая ситуация называется **inaccessible base class**. Если мы допустили такое наследование, то у нас есть поля и методы, к которым мы никак не можем обратиться напрямую, у нас просто нет синтаксиса обратиться к этим полям. Потому что любая попытка обратиться к *g* будет неоднозначность. Обратиться к *g* через Dad мы можем 

    s.Dad::g;
но обратиться к прямому *g* явно мы никак не можем, легально по крайней мере, и все, что остается нам делать, это reinterpret_cast со сдвигами указателей.

Это очень плохое наследование, такого не надо делать. Если так написать, то компилятор кинет нам warning - inaccessible base class. 

---
Представим такую схему:
![alt text](images/9.png)
Напишем

    void(Mom::*p)() = &Mom::f;
    (s.*p)();
можем ли мы так сделать? Мы берем указатель на метод мамы, и по этому указателю вызываем метод у сына. Вообще, мы по-идее должны уметь, потому что метод мамы у сына присутствует. Что такое указатель на метод? Вообще, указатель на метод хранит в себе адрес непосредственно функции, по которой этот метод вызывать. Но если мы делаем такой вызов
    
    (s.*p)();
то просто вызывается эта функция по соответствующему адресы. Но все становится несколько интереснее, если мы напишем:

    void(Dad::*p)() = &Dad::f;
    (s.*p)();
У нас f - это адрес функции. Что из себя представляют указатели на методы? По-идее, указатели на методы - это просто указатели на функцию, и по-идее sizeof(p) должен быть 8. Но благодаря этому примеру сейчас мы поймем, что нет, и что указатели на методы устроены сложнее, чем просто указатели на функции, и что sizeof(p) равен 16, а не 8.

Представим, что у папы есть метод f, а мы вызываемся от сына. Адрес функции остается понятно каким, но мы вызываемся от объекта сына, и внутри этой функции мы должны как-то понимать, что на самом деле поля, с которыми мы сейчас собираемся работать, они сдвинуты относительно начала нашего объекта, от которого мы вызывались.

И на самом деле указатель на метод состоит из двух частей: он хранит адрес функции непосредственно, а еще сдвиг, в котором записано число, показывающее то, на сколько байт начало того объекта, чей это метод, сдвинут относительно начала того объекта, от которого мы вызвались. И в подавляющем большинстве случаев это число будет 0, но в данном случае это число будет 4, потому что мы вызвали папин метод от сына, и в методе мы должны понимать, что адрес объекта, от которого мы работает как будто, она на 4 правее относительно начала того объекта. Это объясняет, почему указатели на методы нельзя хранить как обычные указатели, они реализованы сложнее, а именно они хранят указатель и сдвиг.

**Но вообще это будет CE**. Мы должны написать

    void(Son::*ps)() = p; // implicit cast
именно в этот момент меняется shift, потому что функция остается той же самой, но мы ее теперь понимаем, как указатель на метод сына, а не папы, а значит сдвиг должен измениться на 4

# Virtual inheritance
Вернемся к примеру, когда были Son, Mom, Dad, Granny. Нам не нравится, что у нас создается две копии. Мы хотим так наследоваться, чтобы копия была одна. Такая возможность есть (кстати говоря, вроде как питон делает это по-умолчанию).

Для этого мы можем объявить наследование **виртуальным**:

    struct Granny{};
    struct Mom: public virtual Granny {};
    struct Dad: public virtual Granny {};
    struct Son: public Mom, public Dad {};
т.е. мы пишем virtual перед каждым упоминанием той самой бабушки, которую мы хотим **не** дублировать. Это приводит к тому, что в графе наследования бабушка становится всего одна, и копии его больше нет. И теперь если мы скажем

    Son s;
    s.g;
    Granny& g = s;
или вызов какого-то метода бабушки, то все будет однозначно работать, и будет прекрасно компилироваться, потому что бабушка теперь одна.

Теперь куча вопросов, главный из которых: как это работает?

Как это часто бывает, пытаясь решить одну проблему мы породили 5 новых.

*Кстати, виртуальное наследование используется в STL в basic_iostream, basic_istream, basic_ostream и basic_ios*
![alt text](images/10.png)

А как в памяти это должно размещаться? Представим, что у нас есть поля:
![alt text](images/11.png)
Сколько байт будет занимать в памяти объект s?
    
    #include <iostream>

    struct Granny {
        int g = 0;
    };
    struct Mom : public virtual Granny {
        int m = 1;
    };

    struct Dad : public virtual Granny {
        int d = 2;
    };
    struct Son : public Mom, public Dad {
        int s = 3;
    };

    int main(){
        std::cout << sizeof(Son) << std::endl;
        return 0;
    }
Вывод:

    40

Как можно реализовать то, чтобы у нас была одна копия бабушки, лишь однократно пришлось бы ее копировать при надобности, лишь однократно создавать или уничтожать, и все прочее?

По факту мы делаем следующим образом: мы в начале объекта храним указатель, который указывает на то место, где бабушка начинается **(на самом деле это не совсем так, но дальше будет объяснено, как правильно)**. Потом мы кладем старых предков как обычно, потом сын, и в конце бабушка.
![alt text](images/12.png)

Что, если несколько виртуальных предков? Будет ли столько поинтеров, сколько виртуальных предков? На самом деле нет, и как раз поэтому поинтер указывает не совсем на предка. Будет создана некоторая специальная структура данных в статической памяти, в которой перечислены сдвиги относительно начала объектов до всех виртуальных предков, и поинтер будет не на предка, а на нее. Т.е. для класса Mom будет создана некоторая таблица, в которой будет написано, какие сдвиги относительно начала Mom на виртуальных предков; для Dad будет создана такая же таблица, и для Son будет создана такая же таблица. Т.е. для каждого из типов Mom, Dad, Son в статической памяти будет создана некоторая структура данных, в которой будет для каждого виртуального предка статически перечислен сдвиг относительно начала объекта этого предка
![alt text](images/13.png)
Вот эта таблица в единственном экземпляре существует для каждого типа, и называется **vtable**

# vtable

Напишем:

    Son s;
    Granny& g = s;
    static_cast<Song&>(g);
Можем ли мы сделать static_cast вниз к сыну? Потому что публичное же наследование, а static_cast должен уметь кастовать вниз при публичном наследовании. 

На самом деле static_cast вниз при виртуальном наследовании не работает, просто сдвинуться на shift не получится, потому что если у нас есть такое полное изращение:
![alt text](images/14.png)
то у нас в памяти лежит мама, папа, сын, дочь, внук, и бабушка в самом конце. Мы пытаемся от бабушки скаститься к сыну. Если бы этот сын был просто в сферическом вакууме, то надо было бы 32 вычесть и все, относительно сына 32 начало. Но относительно внука гораздо больше. Откуда статик касту в этот момент знать, что на самом деле мы находимся во внуке, а не в сыне, и таким образом нужно сдвигать гораздо дальше, чем на 32? Ниоткуда. Поэтому static_cast вниз при виртуальном наследовании не работает, это CE. Но вверх static_cast все еще применим.

*Примечание: в объекте сына и мамин поинтер, и папин поинтер указывают на сыновьий vtable, именно поэтому сдвиги правильно и работают (а не на собственные vtable).*

*Примечание 2: от мамы к сыну и от папы к сыну static_cast легко сделать, мы просто делаем сдвиг минус сколько-то. И от сына к бабушке легко, потому что мы смотрим просто в vpointer. А вот от мамы к бабушке не так легко. Например, у нас есть папа, который на самом деле часть сына, и мы хотим сделать каст к бабушке. Мы идем в vtable, там написано 32. Но откуда мы знаем, откуда считать 32? Потому что мы сами не в начале сына находимся. Поэтому на самом деле в vtable нужно хранить еще одно число: сдвиг относительно того, где мы сейчас, и это помимо сдвига виртуальных предков. Чтобы правильно нам нужно сдвинуться, нам нужно знать не только то, насколько далеко бабушка находится от начала объекта, а и то, насколько далеко мы сами находимся от начала объекта, чтобы посчитать разность. Поэтому в виртуальной таблице хранится еще число, которое называется topoffset. Это число показывает, насколько текущее наше положение сдвинуто относительно начала объекта. И казалось бы как так, если у них один и тот же поинтер, но разные сдвиги? На самом деле у них разные поинтеры просто: есть отдельные таблицы MomInSon и DadInSon, и они отличаются тем, что у них topoffset разный.*

---
А что будет, если мы напишем:

    struct Granny{};
    struct Mom: public virtual Granny {};
    struct Dad: public Granny {};
    struct Son: public Mom, public Dad {};
Все будет работать, но в итоге у нас опять две бабушки: одна виртуальная, одна не виртуальная, и проблема дублирования не решена. Теперь у нас опять неоднозначность при каждом из таких обращений, потому что у нас одна бабушка как виртуальная хранится, а другая внутри папы.
![alt text](images/15.png)

---
А что, если мы бы сделали так:

    struct Granny{};
    struct Mom: public Granny {};
    struct Dad: public Granny {};
    struct Son: public virtual Mom, public virtual Dad {};
У нас бы в памяти было так: сначала vptr на таблицу сына, в котором указаны сдвиги мамы и сдвиги папы, затем идет сын, затем начинается виртуальная мама, которая начинается с бабушки, а затем идет мама, потом идет виртуальный папа, который начинается с бабушки, а затем идет папа
![alt text](images/16.png)

---
У нас есть класс V и класс W, и мы виртуально унаследовали V, и не виртуально W
![alt text](images/17.png)
какой метод f выберется? Тут дело вот в чем: метод f из класса B должен затмить метод f из V, но дело в том, что по графу наследования может случиться так, что у нас есть несколько путей до одного и того же класса, и по одним из путей у нас происходит перекрытие имен, а по другим нет. Т.е. когда мы идем по графу какая у нас логика поиска имен: мы идем по этому графу, и когда мы встретили f, мы дальше по графу не идем, он перекрывает методы своих родителей в поиске имен. И если нет виртуальных наследований, то это однозначно все работает. Но если у нас есть виртуальное наследование, то у нас возможна такая ситуация, что у нас несколько путей до одного и того же предка, и как тогда работает поиск имен? А вот как он работает: если хоть по одному пути имя перекрыто, то остальные пути не рассматриваются. Но если у нас будут методы g:
![alt text](images/18.png)
то при вызове *g* у нас будет неоднозначность, потому что она может дойти как до *g* через *C* в *W*, так и до *g* в *B*, и это две разных *g*. *g* в правом *W* никем не перекрыта, а *g* в левом *W* перекрыта посредством *B*, и вот мы двумя путями доходим до *g*. А вызвать *f* не неоднозначность, потому что два разных пути до виртуального предка, и из них рассматривается только один:

    A a;
    a.f(); // OK
    a.g(); // CE
*Примечание: приватность никак не влияет на выбор версии. Это ни на что не повлияет с точки зрения выбора версии, размещения в памяти. Это повляет лишь после того, как все это проделано будет, и однозначно понятно кого вызвать. Если он приватный - CE из-за доступа. ВСЕ ЧТО БЫЛО ВЫШЕ ПРИВАТНОСТЬ НЕ ВЛЯЕТ, ТОЛЬКО КОГДА У НАС ВСЕ ВЫБРАНО И НУЖНО ЛИШЬ ЕГО ВЫЗВАТЬ*
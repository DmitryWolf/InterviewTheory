# Полиморфизм и виртуальные функции
## Идея виртуальных функций
У нас есть код:

    #include <iostream>

    struct Base{
        void f(){
            std::cout << 1 << std::endl;
        }
    };

    struct Derived: Base{
        void f(){
            std::cout << 2 << std::endl;
        }
    };

    int main(){
        Derived d;
        Base& b = d;
        b.f();
    }
Выведется

    1
потому что C++ - это язык со статической типизацией, и тип переменной b это Base&. Поэтому когда мы у Base вызываем f, то поиск имен идет в Base, находит там f, и в ассемблерном коде происходит вызов функции по этому адресу.

Но если так подумать, то не кажется ли это странным поведением, если посмотреть это житейской логикой. Не кажется ли более логичным, чтобы в такой ситуации вызывалась вторая функция, а не первая? В большинстве случаев мы хотим, чтобы в такой ситуации выбиралась вторая версия, а не первая.

**1 пример:** представим, что у нас есть произвольный многоугольник, и у него есть метод вычисления площади. При этом у нас есть квадрат, который является частным случаем многоугольника и у которого можно посчитать за одно умножение как квадрат стороны. Представим, что у нас есть объект Square, и мы говорим:
    
    Polygon& p = s;
т.е. ссылку на многоугольник инициализируем квадратом. Как должна считаться площадь? Как для произвольного многоугольника или как для квадрата? Наверное хотелось бы чтобы как для квадрата, хоть мы и назвали его многоугольником, потому что это эффективнее. И даже если мы имеем дело со ссылкой на общего предка, мы все равно хотим чтобы для нашего конкретного случая делалось как там написано. Мы можем даже абстрагироваться от плюсов: представим, что у нас есть площадь криволинейной трапеции, и она считается как интеграл. И вот у нас такая криволинейная трапеция квадрат из себя на самом деле представляет. Представим, что мы нарисовали квадрат и говорим: "Посчитай, пожалуйста, площадь этой криволинейной трапеции". Как мы будем считать: как интеграл, или скажем: "Это же квадрат, очевидно". Логично, что мы глядя на объект, понимая какого он типа, применяем для него частные случаи операций, даже если мы назвали его общим именем.

**2 пример:** есть поваренная книга, в которой написано как варить разные виды круп. И там есть рецепт как варить произвольную крупу, а есть конкретные рецепты как варить гречку или рис. И нам насыпают рис со словами: "Свари эту крупу". Как мы будем действовать? Мы обнаружим, что это рис, и будет варить ее согласно рекомендациям по варке риса, или мы будем применять общие рекомендации, раз это назвали крупой?

**3 пример (противоположная ситуация):** у нас есть на плоскости два круга. У них одинаковые радиусы, но разные центры. И нас спрашивают, равны ли эти круги. Мы скажем да. Но если у нас спросят: "Эти множества точек равны?", на что мы ответим отрицательно.

*В джаве всегда все виртуальное*

Мы хотим, чтобы независимо от того, что мы имеем дело со ссылкой на Base, вызвался метод Derived, а не Base. Нужно написать ключевое слово **virtual**

    #include <iostream>

    struct Base{
        virtual void f(){
            std::cout << 1 << std::endl;
        }
    };

    struct Derived: Base{
        void f(){
            std::cout << 2 << std::endl;
        }
    };

    int main(){
        Derived d;
        Base& b = d;
        b.f();
    }
Выведется:

    2

**Виртуальная функция** - это такая функция, что будучи вызыванной у объекта по ссылке на родителя, она все равно работает как версия от наследника. То же самое, если мы вызовемся от указателя:

    int main(){
        Derived d;
        Base* b = &d;
        b->f();
    }
Тоже выведется 2. Но если мы напишем

    int main(){
        Derived d;
        Base b = d;
        b.f();
    }
то конечно же выведется 1, потому что никакого наследника нет, а это полноценный Base, это настоящая копия.

Тип, у которого является хотя бы одна виртуальная функция, называется **полиморфным типом**, в том числе и тип, у которого хотя бы одна виртуальная функция унаследована.

Напишем код:

    #include <iostream>

    // polymorphic type
    struct Base{
        virtual void f(){
            std::cout << 1 << std::endl;
        }
    };

    struct Derived: Base{
        int* p = new int(0);
        void f(){
            std::cout << 2 << std::endl;
        }
        ~Derived(){
            delete p;
        }
    };

    int main(){
        Base* b = new Derived();
        delete b;
    }
Что не так в этом коде? Здесь утечка памяти. Деструктор, как и любой метод, вызывается от того типа, от которого наша переменная. Если мы делаем delete b, где b это указатель на Base, а не Derived, то и деструктор вызовется от Base, и при этом ~Derived() не выполнется.

delete на самом деле состоит из двух частей: он вызывает деструктор и память освобождает. new выделяет память и вызывает конструктор на этой памяти, а delete вызывает деструктор и освобождает память. Это ключевое отличие new от malloc, и delete от free.

Соответственно, чтобы вызвался деструктор того типа, который был там на самом деле, а не того типа, которого мы переменную завели, нужно чтобы деструктор был тоже помечен как virtual

    #include <iostream>

    // polymorphic type
    struct Base{
        virtual void f(){
            std::cout << 1 << std::endl;
        }
        virtual ~Base() = default;
    };

    struct Derived: Base{
        int* p = new int(0);
        void f(){
            std::cout << 2 << std::endl;
        }
        ~Derived(){
            delete p;
        }
    };

    int main(){
        Base* b = new Derived();
        delete b;
    }

Обязательно нужно делать виртуальный деструктор, если у нас есть какое-то наследование с виртуальной функцией.

## More complicated examples with virtual functions
Неважно, пишем ли мы слово virtual только в родителе, или в родителе и наследнике. Главное, чтобы было написано в родителе.

Если у нас функция отличается сигнатурой, то она не становится виртуальной. Виртуальной считается только функция, которая в точности совпадает по сигнатуре.

### override

Типичная ошибка:

    #include <iostream>

    // polymorphic type
    struct Base{
        virtual void f() const{
            std::cout << 1 << std::endl;
        }
    };

    struct Derived: Base{
        // void f() const{
        //     std::cout << 2 << std::endl;
        // }
        void f(){
            std::cout << 3 << std::endl;
        }
    };

    int main(){
        Derived d;
        Base& b = d;
        b.f();
    }
Вывод:

    3
потому что у нас не совпадает сигнатура в наследнике, а это значит, что эта функция не является виртуальной, и не переопределяет ту, которая в родителе. В связи с чем, если мы хотя бы немного ошиблись в сигнатуре переопределяемой функции в наследнике, то мы потеряем виртуальность. Более того, если мы допишем так:

    struct Derived: Base{
        // void f() const{
        //     std::cout << 2 << std::endl;
        // }
        virtual void f(){
            std::cout << 3 << std::endl;
        }
    };
то это виртуальная функция, которая может быть вниз продолжена кем-либо, но это две разные версии f, одна другую не продолжает. Поэтому в C++ (since c++11) есть ключевое слово **override** - это важное правило кодстайла, которое нужно применять при написании виртуальных функций.

Когда мы переопределяем виртуальную функцию, то слово virtual повторять необязательно, но вот что надо делать - это писать override. Слово override пишется после сигнатуры и говорит компилятору, что этим самым мы хотим переопределить какую-то виртуальную функцию из одного из родителей. Зачем это нужно? Если мы написали override, а на самом деле у нас нет такой виртуальной функции у родителя, то мы получим CE.

override нужно не для того, чтобы заставить нашу функцию переопределять родительскую. Вне зависимости от того, напишем мы override или нет, если мы сигнатуру правильно воспроизвели, то функция будет переопределять родительскую. Слово override нужно для того, чтобы иногда добавить нам ошибок компиляции.

Типичная ошибка: у человека спрашивают: "Что такое виртуальная функция?", а он отвечает: "Виртуальная функция - это такая, которую можно оверрайдить". Ты спрашиваешь: "Что значит оверрайдить?", тебе отвечают: "Ну переопределять в наследнике то есть", а ты в ответ: "А, то есть обычные функции нельзя переопределять в наследнике?", и в ответ получаешь: "Нуу... наверное нет". Вот это грубая ошибка, потому что переопределять можно любые функции, хоть виртуальные, хоть не виртуальные. Оверрайдить можно только виртуальные функции, но это не определие того, что такое виртуальная функция. Слово override нужно совсем не для того, чтобы что-то оверрайдить, оно нужно для того, чтобы добавить нам ошибок компиляции, чтобы избежать неинтуитивного поведения. Т.е. в таком определении перепутаны причина и следствие.

---
Что будет, если мы возвращаемый тип сделаем другим? Будет CE, потому что когда мы виртуальную функцию переопределяем, то если мы такую же сигнатуру сделаем, когда мы виртуальную функцию переопределяем, если мы такую же сигнатуру сделаем, но возвращаемый тип другой, ну так нельзя, это типо получается что в зависимости от того, у нас родитель или наследник, то разные типы вернутся.

### final
Для виртуальных функций можно написать final - это будет означать, что мы запрещаем всем дальнейшим своим наследникам переопределять эту функцию, при этом мы не запрещаем им объявлять функцию с такой же сигнатурой, мы запрещаем им только лишь с такой же сигнатурой объявлять, чтобы она переопределяла мою.

Иногда это бывает полезно, иногда это улучшает скорость работы кода.

Слово final не добавляет нам никакой функциональности, оно добавляет нам лишние ошибки компиляции. Но глубокий смысл слова final в том, что оно позволяет компилятору делать некоторые оптимизации, зная, что никто ниже эту функцию не переопределяет.

Как писать слова override и final? Утверждение следующее: из слов override и final нужно максимум одно. final автоматически означает override, но не наоборот. Хотя никто не запрещает написать оба слова override final

Следующая мысль: из слов virtual, override и final всегда нужно максимум одно. 
* Если мы определяем новую виртуальную функцию, то мы пишем virtual
* Если мы переопределяем уже существующую виртуальную функцию, то мы пишем override и virtual из него уже автоматически следует
* Если мы доопределяем последнюю, то мы пишем final, из него автоматически следует override, из него автоматически следует virtual

---
### Other examples
Мы можем написать:

    int override = 5;
и все скомпилируется. Казалось бы, override и final это ключевые слова. Но на самом деле это контекстно зависимые слова. override не является встроенным в язык ключевым словом, оно несет определенный смысл только в определенном контексте. Но при этом объявить переменную с названием override мы можем. Зачем так сделано? Потому что слова добавились позже (в c++11), чем вышел первый стандарт языка, и если бы эти слова сделали бы ключевыми словами, то получилось бы, что старый код перестал бы компилироваться.

---
Если у нас в иерархии много функций и они в линейку выстроены, то вызывается самая глубокая из тех, которые реально у нас присутствуют исходя из того, кем мы были изначально.

    #include <iostream>

    // polymorphic type
    struct Granny{
        virtual void f() const {
            std::cout << 1 << std::endl;
        }
    };

    struct Mom: Granny{
        void f() const override {
            std::cout << 2 << std::endl;
        }
    };

    struct Son: Mom{
        void f() const final {
            std::cout << 3 << std::endl;
        }
    };

    int main(){
        Mom m;
        Granny& g = m;
        g.f();
    }
Вывод:

    2
А теперь добавим приватность:

    struct Mom: Granny{
    private: // updated
        void f() const override {
            std::cout << 2 << std::endl;
        }
    };
У нас есть мама, у нее приватная f. Мы сделали ссылку на бабушку и вызвали у нее f. Но изначально это была мама. То какая функция вызовется? Все равно вызовется f у мамы, и выведется 2. И это контринтуитивно, но почему так работает? Правильный ответ такой: виртуальные функции это runtime явления, а приватность это compile-time явления. То, какая именно функция будет выбрана, определяется в runtime, и определяется в зависимости от того, что под объектом лежит на самом деле. А легален ли этот вызов определяется в compile-time, и в compile-time компилятор не может никак определить, какая функция будет выбрана, и он не может кинуть нам CE, просто по той причине, что он не знает, в какую функцию мы попадем, в приватную или публичную.

    int main(){
        Mom m;
        Granny g;
        int x;
        std::cin >> x;
        Granny& gg = (x % 2 ? m : g);
        gg.f();
    }
Выведется либо 1, либо 2, в зависимость от того, какое число мы ввели с клавиатуры. Это пример, который доказывает, что в compile-time невозможно определить, какая из виртуальных функций должа вызваться. А соответственно компилятор должен всегда кидать CE в таких ситуациях, либо всегда забивать на приватность. Ну и он забивает на приватность, потому что приватность он не в состоянии проверить.

Выбор версии виртуальной функции - это runtime, поэтому приватность здесь ни на что не влияет.

Но влияет приватность исходного объекта:

    #include <iostream>

    struct Granny{
    private:
        virtual void f() const {
            std::cout << 1 << std::endl;
        }
    };

    struct Mom: Granny{
        void f() const override {
            std::cout << 2 << std::endl;
        }
    };

    struct Son: Mom{
        void f() const final {
            std::cout << 3 << std::endl;
        }
    };

    int main(){
        {
            Mom m;
            Granny& g = m;
            g.f(); // CE
        }
        {
            Mom m;
            Granny g;
            int x;
            std::cin >> x;
            Granny& gg = (x % 2 ? m : g);
            gg.f(); // CE
        }
    }
Приватность зависит только от того, от какого типа мы вызвались в compile-time.

---
У нас есть такой код:

    #include <iostream>

    struct Mom {
        virtual void f() {
            std::cout << 1 << std::endl;
        }
    };

    struct Dad {
        void f(){
            std::cout << 2 << std::endl;
        }
    };

    struct Son: Mom, Dad {
        void f() override {
            std::cout << 3 << std::endl;
        }
    };

    int main(){
    }
Будет ли виртуальной f в Son? Скомпилируется ли код? На самом деле да, будет считаться, что она виртуальная.

Другой вопрос: что, если функция будет виртуальная и в Mom, и в Dad, то какую из них функция f в Son будет продолжать в реальности? Т.е. если мы вызовемся от мамы, и вызовемся от папы, оба ли раза мы получим 3?

    #include <iostream>

    struct Mom {
        virtual void f() {
            std::cout << 1 << std::endl;
        }
    };

    struct Dad {
        virtual void f(){
            std::cout << 2 << std::endl;
        }
    };

    struct Son: Mom, Dad {
        void f() override {
            std::cout << 3 << std::endl;
        }
    };

    int main(){
        Son s;
        Mom& m = s;
        Dad& d = s;
        m.f();
        d.f();
    }
Вывод:

    3
    3
Т.е. обе эти виртуальные функции на самом деле подцепили нижнюю версию. И в целом это объясняет, почему если одна виртуальная, а одна нет, то итоговая виртуальная. Т.е. если хотя бы одна сверху виртуальная, то она подцепляет нижнюю.
Если бы у кого-то была функция не виртуальная:

    #include <iostream>

    struct Mom {
        virtual void f() {
            std::cout << 1 << std::endl;
        }
    };

    struct Dad {
        void f(){
            std::cout << 2 << std::endl;
        }
    };

    struct Son: Mom, Dad {
        void f() override {
            std::cout << 3 << std::endl;
        }
    };

    int main(){
        Son s;
        Mom& m = s;
        Dad& d = s;
        m.f();
        d.f();
    }
Вывод:

    3
    2
Про приватность: приватность зависит только от того, у кого мы вызывались статически.

А что, если бы у нас была бабушка, и у нее была бы f, а потом мама бы переопределила ее, сделав ее виртуальной, и сын тоже сделал бы свою f. Т.е. у бабушки есть просто функция f, у мамы есть виртуальная функция f, и у сына есть f. Что будет? f у сына будет виртуальной, и подцепит к маминому. Т.е. если мы вызываемся от бабушки, то никакой виртуальности нет, а если вызывались у мамы, то уже есть виртуальность вниз, и поэтому если мы вызвались у мамы и был сын, будет сыновья версия, а если мы вызвались у бабушки и была мама, не будет маминой версии, будет бабушкина версия.

---
Слово final можно применять не только к функциям, но и к самим классам. Это для того, чтобы больше нельзя было наследовать их (since c++11).

## Abstract classes and pure virtual function
Часто бывает такое, что мы объявляем в классе виртуальную функцию, но мы не знаем, как ее определить, потому что этот абстрактный тип слишком общий, чтобы для него это можно было бы как-то определить. Классический пример: у нас класс Shape - фигура на плоскости, и у него метод площадь/периметр. Мы не можем его определить, потому что для произвольной фигуры нельзя посчитать площадь. Но мы хотим в то же время, чтобы любой, кто наследуется от нашей фигуры, имел этот метод у себя. Т.е. любой, кто имеет ссылку на фигуру, знал, что у фигуры есть метод Area, и его можно вызывать. Но сам по себе класс Shape не определяет метод Area, любой наследник должен его определять, но исходный класс не должен его определять. Такие классы еще иногда называются **интерфейсы** (в Java есть такое понятие, вроде еще в C#). На самом деле в C++ нет понятия интерфейс, понятия "абстрактный класс" и "интерфейс" не отличаются.

Метод называется **pure virtual**, если он virtual и про него написано, что он равен нулю.

    virtual double area() const = 0;
    
Что такое **абстрактный класс/интерфейс**? Это такой класс, у которого есть хотя бы одна виртуальная функция, если у него есть хотя бы один pure virtual метод.

    struct Shape {
        virtual double area() const = 0;
        virtual ~Shape() = default;
    };
Мы не можем создать объект абстрактного типа. Но мы можем сделать так:

    #include <iostream>

    struct Shape {
        virtual double area() const = 0;
        virtual ~Shape() = default;
    };

    struct Square: Shape {
        double a;
        Square(double a): a(a) {}
        double area() const override {
            return a * a;
        }
    };

    struct Circle: Shape {
        double r;
        Circle(double r): r(r) {}
        double area() const override {
            return 3.14159265358 * r * r;
        }
    };

    int main(){
        Square sq(1.0);
        Shape& s = sq;
        s.area();
    }

## Что такое полиморфизм?
У нас есть Square и Circle, и оба они частные случаи Shape. Мы можем завести вектор указателей на Shape (не вектор Shape потому что объекты Shape мы не можем создавать, и вектор ссылок на Shape мы тоже завести не можем), и положить туда new Square и new Circle

    #include <iostream>
    #include <vector>

    struct Shape {
        virtual double area() const = 0;
        virtual ~Shape() = default;
    };

    struct Square: Shape {
        double a;
        Square(double a): a(a) {}
        double area() const override {
            return a * a;
        }
    };

    struct Circle: Shape {
        double r;
        Circle(double r): r(r) {}
        double area() const override {
            return 3.14159265358 * r * r;
        }
    };

    int main(){
        std::vector<Shape*> v;
        v.push_back(new Square(1.0));
        v.push_back(new Circle(1.0));
        for (Shape* s : v){
            std::cout << s->area() << std::endl;
        }
        for (Shape* s : v){
            delete s;
        }
    }
Под каждым из Shape* лежит какой-то реальный объект, и типы этих объектов разные. Это как раз таки **полиморфизм**

**Полиморфизм** - это такое языковое средство, когда мы можем, обращаясь к объекту, используя одно и то же имя, и одно и то же название и действие, получать разное, в зависимости от того, что там было на самом деле. Это стандартный паттерн: когда у нас есть контейнер указателей на общий тип (абстрактный, возможно), но под каждым из указателей лежит какой-то конкретный тип. Мы говорим им что-то сделать, и мы называем одно и то же действие, но каждый из них делает это по-разному. Все мы разные, все мы умеем делать какие-то действия, но каждый может понимать их по-своему.

Есть понятия статический полиморфизм и динамический полиморфизм:
* Статический полиморфизм - это перегрузка функции по-сути, ведь когда мы говорим "a+b", это тоже может означать разное, смотря какие типы были. Называется операция одинаково, но в зависимости от типов она будет разные вещи делать. Определяется в compile-time
* Динамический полиморфизм - какая именно будет операция определяется в runtime
# Полиморфизм и виртуальные функции
## Идея виртуальных функций
У нас есть код:

    #include <iostream>

    struct Base{
        void f(){
            std::cout << 1 << std::endl;
        }
    };

    struct Derived: Base{
        void f(){
            std::cout << 2 << std::endl;
        }
    };

    int main(){
        Derived d;
        Base& b = d;
        b.f();
    }
Выведется

    1
потому что C++ - это язык со статической типизацией, и тип переменной b это Base&. Поэтому когда мы у Base вызываем f, то поиск имен идет в Base, находит там f, и в ассемблерном коде происходит вызов функции по этому адресу.

Но если так подумать, то не кажется ли это странным поведением, если посмотреть это житейской логикой. Не кажется ли более логичным, чтобы в такой ситуации вызывалась вторая функция, а не первая? В большинстве случаев мы хотим, чтобы в такой ситуации выбиралась вторая версия, а не первая.

**1 пример:** представим, что у нас есть произвольный многоугольник, и у него есть метод вычисления площади. При этом у нас есть квадрат, который является частным случаем многоугольника и у которого можно посчитать за одно умножение как квадрат стороны. Представим, что у нас есть объект Square, и мы говорим:
    
    Polygon& p = s;
т.е. ссылку на многоугольник инициализируем квадратом. Как должна считаться площадь? Как для произвольного многоугольника или как для квадрата? Наверное хотелось бы чтобы как для квадрата, хоть мы и назвали его многоугольником, потому что это эффективнее. И даже если мы имеем дело со ссылкой на общего предка, мы все равно хотим чтобы для нашего конкретного случая делалось как там написано. Мы можем даже абстрагироваться от плюсов: представим, что у нас есть площадь криволинейной трапеции, и она считается как интеграл. И вот у нас такая криволинейная трапеция квадрат из себя на самом деле представляет. Представим, что мы нарисовали квадрат и говорим: "Посчитай, пожалуйста, площадь этой криволинейной трапеции". Как мы будем считать: как интеграл, или скажем: "Это же квадрат, очевидно". Логично, что мы глядя на объект, понимая какого он типа, применяем для него частные случаи операций, даже если мы назвали его общим именем.

**2 пример:** есть поваренная книга, в которой написано как варить разные виды круп. И там есть рецепт как варить произвольную крупу, а есть конкретные рецепты как варить гречку или рис. И нам насыпают рис со словами: "Свари эту крупу". Как мы будем действовать? Мы обнаружим, что это рис, и будет варить ее согласно рекомендациям по варке риса, или мы будем применять общие рекомендации, раз это назвали крупой?

**3 пример (противоположная ситуация):** у нас есть на плоскости два круга. У них одинаковые радиусы, но разные центры. И нас спрашивают, равны ли эти круги. Мы скажем да. Но если у нас спросят: "Эти множества точек равны?", на что мы ответим отрицательно.

*В джаве всегда все виртуальное*

Мы хотим, чтобы независимо от того, что мы имеем дело со ссылкой на Base, вызвался метод Derived, а не Base. Нужно написать ключевое слово **virtual**

    #include <iostream>

    struct Base{
        virtual void f(){
            std::cout << 1 << std::endl;
        }
    };

    struct Derived: Base{
        void f(){
            std::cout << 2 << std::endl;
        }
    };

    int main(){
        Derived d;
        Base& b = d;
        b.f();
    }
Выведется:

    2

Виртуальная функция - это такая функция, что будучи вызыванной у объекта по ссылке на родителя, она все равно работает как версия от наследника. То же самое, если мы вызовемся от указателя:

    int main(){
        Derived d;
        Base* b = &d;
        b->f();
    }
Тоже выведется 2. Но если мы напишем

    int main(){
        Derived d;
        Base b = d;
        b.f();
    }
то конечно же выведется 1, потому что никакого наследника нет, а это полноценный Base, это настоящая копия.

Тип, у которого является хотя бы одна виртуальная функция, называется **полиморфным типом**, в том числе и тип, у которого хотя бы одна виртуальная функция унаследована.

Напишем код:

    #include <iostream>

    // polymorphic type
    struct Base{
        virtual void f(){
            std::cout << 1 << std::endl;
        }
    };

    struct Derived: Base{
        int* p = new int(0);
        void f(){
            std::cout << 2 << std::endl;
        }
        ~Derived(){
            delete p;
        }
    };

    int main(){
        Base* b = new Derived();
        delete b;
        return 0;
    }
Что не так в этом коде? Здесь утечка памяти. Деструктор, как и любой метод, вызывается от того типа, от которого наша переменная. Если мы делаем delete b, где b это указатель на Base, а не Derived, то и деструктор вызовется от Base, и при этом ~Derived() не выполнется.

delete на самом деле состоит из двух частей: он вызывает деструктор и память освобождает. new выделяет память и вызывает конструктор на этой памяти, а delete вызывает деструктор и освобождает память. Это ключевое отличие new от malloc, и delete от free.

Соответственно, чтобы вызвался деструктор того типа, который был там на самом деле, а не того типа, которого мы переменную завели, нужно чтобы деструктор был тоже помечен как virtual

    #include <iostream>

    // polymorphic type
    struct Base{
        virtual void f(){
            std::cout << 1 << std::endl;
        }
        virtual ~Base() = default;
    };

    struct Derived: Base{
        int* p = new int(0);
        void f(){
            std::cout << 2 << std::endl;
        }
        ~Derived(){
            delete p;
        }
    };

    int main(){
        Base* b = new Derived();
        delete b;
        return 0;
    }
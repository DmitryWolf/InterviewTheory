# Полиморфизм и виртуальные функции
## Идея виртуальных функций
У нас есть код:

    #include <iostream>

    struct Base{
        void f(){
            std::cout << 1 << std::endl;
        }
    };

    struct Derived: Base{
        void f(){
            std::cout << 2 << std::endl;
        }
    };

    int main(){
        Derived d;
        Base& b = d;
        b.f();
    }
Выведется

    1
потому что C++ - это язык со статической типизацией, и тип переменной b это Base&. Поэтому когда мы у Base вызываем f, то поиск имен идет в Base, находит там f, и в ассемблерном коде происходит вызов функции по этому адресу.

Но если так подумать, то не кажется ли это странным поведением, если посмотреть это житейской логикой. Не кажется ли более логичным, чтобы в такой ситуации вызывалась вторая функция, а не первая? В большинстве случаев мы хотим, чтобы в такой ситуации выбиралась вторая версия, а не первая.

**1 пример:** представим, что у нас есть произвольный многоугольник, и у него есть метод вычисления площади. При этом у нас есть квадрат, который является частным случаем многоугольника и у которого можно посчитать за одно умножение как квадрат стороны. Представим, что у нас есть объект Square, и мы говорим:
    
    Polygon& p = s;
т.е. ссылку на многоугольник инициализируем квадратом. Как должна считаться площадь? Как для произвольного многоугольника или как для квадрата? Наверное хотелось бы чтобы как для квадрата, хоть мы и назвали его многоугольником, потому что это эффективнее. И даже если мы имеем дело со ссылкой на общего предка, мы все равно хотим чтобы для нашего конкретного случая делалось как там написано. Мы можем даже абстрагироваться от плюсов: представим, что у нас есть площадь криволинейной трапеции, и она считается как интеграл. И вот у нас такая криволинейная трапеция квадрат из себя на самом деле представляет. Представим, что мы нарисовали квадрат и говорим: "Посчитай, пожалуйста, площадь этой криволинейной трапеции". Как мы будем считать: как интеграл, или скажем: "Это же квадрат, очевидно". Логично, что мы глядя на объект, понимая какого он типа, применяем для него частные случаи операций, даже если мы назвали его общим именем.

**2 пример:** есть поваренная книга, в которой написано как варить разные виды круп. И там есть рецепт как варить произвольную крупу, а есть конкретные рецепты как варить гречку или рис. И нам насыпают рис со словами: "Свари эту крупу". Как мы будем действовать? Мы обнаружим, что это рис, и будет варить ее согласно рекомендациям по варке риса, или мы будем применять общие рекомендации, раз это назвали крупой?

**3 пример (противоположная ситуация):** у нас есть на плоскости два круга. У них одинаковые радиусы, но разные центры. И нас спрашивают, равны ли эти круги. Мы скажем да. Но если у нас спросят: "Эти множества точек равны?", на что мы ответим отрицательно.

*В джаве всегда все виртуальное*

Мы хотим, чтобы независимо от того, что мы имеем дело со ссылкой на Base, вызвался метод Derived, а не Base. Нужно написать ключевое слово **virtual**

    #include <iostream>

    struct Base{
        virtual void f(){
            std::cout << 1 << std::endl;
        }
    };

    struct Derived: Base{
        void f(){
            std::cout << 2 << std::endl;
        }
    };

    int main(){
        Derived d;
        Base& b = d;
        b.f();
    }
Выведется:

    2

**Виртуальная функция** - это такая функция, что будучи вызыванной у объекта по ссылке на родителя, она все равно работает как версия от наследника. То же самое, если мы вызовемся от указателя:

    int main(){
        Derived d;
        Base* b = &d;
        b->f();
    }
Тоже выведется 2. Но если мы напишем

    int main(){
        Derived d;
        Base b = d;
        b.f();
    }
то конечно же выведется 1, потому что никакого наследника нет, а это полноценный Base, это настоящая копия.

Тип, у которого является хотя бы одна виртуальная функция, называется **полиморфным типом**, в том числе и тип, у которого хотя бы одна виртуальная функция унаследована.

Напишем код:

    #include <iostream>

    // polymorphic type
    struct Base{
        virtual void f(){
            std::cout << 1 << std::endl;
        }
    };

    struct Derived: Base{
        int* p = new int(0);
        void f(){
            std::cout << 2 << std::endl;
        }
        ~Derived(){
            delete p;
        }
    };

    int main(){
        Base* b = new Derived();
        delete b;
    }
Что не так в этом коде? Здесь утечка памяти. Деструктор, как и любой метод, вызывается от того типа, от которого наша переменная. Если мы делаем delete b, где b это указатель на Base, а не Derived, то и деструктор вызовется от Base, и при этом ~Derived() не выполнется.

delete на самом деле состоит из двух частей: он вызывает деструктор и память освобождает. new выделяет память и вызывает конструктор на этой памяти, а delete вызывает деструктор и освобождает память. Это ключевое отличие new от malloc, и delete от free.

Соответственно, чтобы вызвался деструктор того типа, который был там на самом деле, а не того типа, которого мы переменную завели, нужно чтобы деструктор был тоже помечен как virtual

    #include <iostream>

    // polymorphic type
    struct Base{
        virtual void f(){
            std::cout << 1 << std::endl;
        }
        virtual ~Base() = default;
    };

    struct Derived: Base{
        int* p = new int(0);
        void f(){
            std::cout << 2 << std::endl;
        }
        ~Derived(){
            delete p;
        }
    };

    int main(){
        Base* b = new Derived();
        delete b;
    }

Обязательно нужно делать виртуальный деструктор, если у нас есть какое-то наследование с виртуальной функцией.

## More complicated examples with virtual functions
Неважно, пишем ли мы слово virtual только в родителе, или в родителе и наследнике. Главное, чтобы было написано в родителе.

Если у нас функция отличается сигнатурой, то она не становится виртуальной. Виртуальной считается только функция, которая в точности совпадает по сигнатуре.

### override

Типичная ошибка:

    #include <iostream>

    // polymorphic type
    struct Base{
        virtual void f() const{
            std::cout << 1 << std::endl;
        }
    };

    struct Derived: Base{
        // void f() const{
        //     std::cout << 2 << std::endl;
        // }
        void f(){
            std::cout << 3 << std::endl;
        }
    };

    int main(){
        Derived d;
        Base& b = d;
        b.f();
    }
Вывод:

    3
потому что у нас не совпадает сигнатура в наследнике, а это значит, что эта функция не является виртуальной, и не переопределяет ту, которая в родителе. В связи с чем, если мы хотя бы немного ошиблись в сигнатуре переопределяемой функции в наследнике, то мы потеряем виртуальность. Более того, если мы допишем так:

    struct Derived: Base{
        // void f() const{
        //     std::cout << 2 << std::endl;
        // }
        virtual void f(){
            std::cout << 3 << std::endl;
        }
    };
то это виртуальная функция, которая может быть вниз продолжена кем-либо, но это две разные версии f, одна другую не продолжает. Поэтому в C++ (since c++11) есть ключевое слово **override** - это важное правило кодстайла, которое нужно применять при написании виртуальных функций.

Когда мы переопределяем виртуальную функцию, то слово virtual повторять необязательно, но вот что надо делать - это писать override. Слово override пишется после сигнатуры и говорит компилятору, что этим самым мы хотим переопределить какую-то виртуальную функцию из одного из родителей. Зачем это нужно? Если мы написали override, а на самом деле у нас нет такой виртуальной функции у родителя, то мы получим CE.

override нужно не для того, чтобы заставить нашу функцию переопределять родительскую. Вне зависимости от того, напишем мы override или нет, если мы сигнатуру правильно воспроизвели, то функция будет переопределять родительскую. Слово override нужно для того, чтобы иногда добавить нам ошибок компиляции.

Типичная ошибка: у человека спрашивают: "Что такое виртуальная функция?", а он отвечает: "Виртуальная функция - это такая, которую можно оверрайдить". Ты спрашиваешь: "Что значит оверрайдить?", тебе отвечают: "Ну переопределять в наследнике то есть", а ты в ответ: "А, то есть обычные функции нельзя переопределять в наследнике?", и в ответ получаешь: "Нуу... наверное нет". Вот это грубая ошибка, потому что переопределять можно любые функции, хоть виртуальные, хоть не виртуальные. Оверрайдить можно только виртуальные функции, но это не определие того, что такое виртуальная функция. Слово override нужно совсем не для того, чтобы что-то оверрайдить, оно нужно для того, чтобы добавить нам ошибок компиляции, чтобы избежать неинтуитивного поведения. Т.е. в таком определении перепутаны причина и следствие.

---
Что будет, если мы возвращаемый тип сделаем другим? Будет CE, потому что когда мы виртуальную функцию переопределяем, то если мы такую же сигнатуру сделаем, когда мы виртуальную функцию переопределяем, если мы такую же сигнатуру сделаем, но возвращаемый тип другой, ну так нельзя, это типо получается что в зависимости от того, у нас родитель или наследник, то разные типы вернутся.

### final
// TODO
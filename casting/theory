2.6. Casts.

// C-style cast
double d = 0.0;
int x = (int) d;

// LLVM cpp code-style
1. static_cast
    Естественное преобразование типов
    Если нужен каст, но не знаем какой
    Когда нужно привести тип к другому типу так, как естественно понимаем это
    Самое обычное приведение типов по имеющимся правилам приведения типа
    Создаёт новую копию из имеющегося объекта
2. reinterpret_cast
    Трактуем участок памяти иначе, т.е. берем байты в памяти и трактуем как байты памяти другого типа
    НЕ создает копию
    + позволяет кастовать указатели на произвольные типы. Если у нас указатель на что-то, 
        то мы можем скастовать его на что-то угодно другое. 
        Компилятор будет думать что там лежит что-то другое
    reinterpret_cast между указателями - ок
    reinterpret_cast между ссылками - ыыээ сомнительно

    // soft
    int x = 0;
    int* p = &x;
    dobule* pd = reinterpret_cast<double*>(p);

    // hardcore
    double d = 3.14;
    int* pp = reinterpret_cast<int*&>(d);

3. const_cast
    Позволяет нам неконстантный тип привести к константному (и наоборот)
    НЕ создаем копию, а трактуем имеющийся объект иначе (работает с указателями и ссылками)

    void f(int&) {std::cout << 1 << std::endl;}
    void f(const int&) {std::cout << 2 << std::endl;}
    int n = 5;
    // soft (type -> const type)
    f(n); 
    f(const_cast<const int&>(n));

    // hardcore (const type -> type)
    const int& cn = n;
    f(const_cast<int&>(cn));

4. C-style cast (https://en.cppreference.com/w/cpp/language/explicit_cast)
    Самый грубый каст
    When the C-style cast expression is encountered, the compiler attempts 
        to interpret it as the following cast expressions, in this order:
    a) const_cast<target-type>(expression);
    b) static_cast<target-type>(expression), with extensions: pointer or reference to a derived class 
        is additionally allowed to be cast to pointer or reference to unambiguous base class 
        (and vice versa) even if the base class is inaccessible 
        (that is, this cast ignores the private inheritance specifier). 
        Same applies to casting pointer to member to pointer to member of unambiguous non-virtual base;
    c) static_cast (with extensions) followed by const_cast;
    d) reinterpret_cast<target-type>(expression);
    e) reinterpret_cast followed by const_cast.
    else compile-error
    ОЧЕНЬ ПЛОХО! потому что даже не знаем, какой каст сработал

5. RTTI and dynamic_cast
    dynamic_cast это каст в runtime (static это в момент компиляции, dynamic это в runtime)
    Например, у static_cast уже в compile-time известно, он успешен или ошибка компиляции
    dynamic_cast может в runtime вернуть ошибку и будет RE, а может работать правильно
    В чем отличие от static_cast? В следующем примере static_cast даст UB, а dynamic_cast даст исключение std::bad_cast
        struct Base {}
        struct Derived : Base {}
        Derived d;
        Base& b = d;
        // При неправильном касте будет std::bad_cast
        dynamic_cast<Derived&>(b);
        // При неправильном касте будет nullptr
        Derived* pd = dynamic_cast<Derived*>(&b);
    Работает только для типов с виртуальными функциями, т.к. для типов, у которых нет виртуальных функций,
    никак нет в runtime способа узнать, что это за тип на самом деле. Ведь тип с виртуальными функциями, 
    полиморфный тип другими словами, это как раз такой тип, про который в runtime каким-то образом
    поддерживается специальная информация, по которой в runtime понятно, что это на самом деле,
    и в зависимости от этого что вызвать. Если в классе нет ни одной виртуальной функции,
    то dynamic_cast делать нельзя, это CE

    Довольно таки дорогая операция, т.к. чтобы сделать dynamic_cast нужно в runtime сходить
    по некоторому указателю, который хранится в нашем объекте, найти virtual table, по ней
    посмотреть, что там написано, и в зависимости от этого понять, какой же это реально тип,
    и в зависимости от этого понять, можно ли dynamic_cast сделать или нет

    В compile-time нельзя понять, что на самом деле лежит под ссылкой.
    Например мы можем ввести число, и ссылку на Base проинициализировать либо объектом Base,
    либо объектом Derived, в зависимости от того, какое число было введено, и непонятно,
    что под ссылкой до runtime
    Это все механизм RTTI (RunTime Type Information)

    Для полиморфных типов компилятор поддерживает специальную структуру, в которой
    хранит, что это за тип на самом деле.

        Derived d;
        Base& b = d;
        typeid(b); // вернет std::type_info
        /*
        есть оператор сравнение, равенство будет т.ит.д., когда это одинаковые типы
        есть метод name, возвращающий const char, в котором написано название типа
        */
        std::cout << typeid(b).name() << "\n"; // для полиформных типов выведет название типа, который реально был под ссылкой, а не тип переменной, от которой мы вызвались
        int x = 1;
        typeid(x); // работает и не для полиморфных типов, но для них выводит просто тип переменной

    1) От любого полифорного типа всегда можно делать dynamic_cast ко звездочке, а от неполиморфного нельзя.
    Таким образом можно проверить, является ли тип полиморфным
    2) Всегда можно делать dynamic_cast вверх, даже если тип не полиморфный.
    Но это не значит, что нам всегда нужно использовать dynamic_cast, он нужен, когда у нас в runtime нужны проверки,
    когда у нас есть виртуальности нетривиальные. В остальных случаях нас должен устраивать static_cast
    (если мы юзаем dynamic_cast от наследника к родителю, то в обратную сторону будет CE, а при static_cast будет UB)
    3) Умеет кастовать вбок (от мамы к папе). Если у нас есть множественное наследование (например: сын, мама, папа, бабушка),
    static_cast неоткуда узнать, что мама папа совместимые типы, а dynamic_cast может посмотреть, что типы на самом деле сын
    (пример: есть ссылка на маму, хотим скастовать к ссылке на папу. dynamic_cast идет в таблицу и смотрит, что на самом
    деле тип сын, а каст от мамы, значит, чтобы сделать каст к папе, нужно сдвинуться на столько, и понимает на сколько,
    потому что он знает, как сын в памяти размещается, это известно еще на стадии компиляции)
    Если каст вниз или вбок: полиморфным должен быть тот, от кого делается dynamic_cast
    Если от наследника к родителю: каст можно даже если нет никакого полиморфизма

    Если нужно сделать тип полиморфным, но виртуальных функций никаких не требуетяс, то можно сделать виртуальный деструктор

    Если мы делаем delete p, где p это указатель на родителя, хотя там на самом деле лежит наследник, то нам нужен виртуальный деструктор
    Даже если у нас сам деструктор derived тривиальный, но у него есть поля, у которых есть нетривиальные деструкторы, то все,
    без виртуального деструктора мы проиграли

    4) Виртуальное наследование, и мы кастим вниз от виртуального предка (нужно, чтобы виртуальный предок был полиморфным)

    Два примера, когда static_cast, dynamic_cast, reinterpret_cast дают разные результаты:
    1) Кастим вбок от мамы к папе:
        static_cast дает CE
        dynamic_cast корректно отрабатывает
        reinterpret_cast дает UB
    2) Кастим вниз при виртуальном наследовании (при условии, что предок полиморфный)
        static_cast дает CE
        dynamic_cast корректно отрабатывает
        reinterpret_cast дает UB
    
    Виртуальная функция - это такая функция, что если по ссылке или указателю на базовый класс ее вызвать, то все равно вызовется версия дочернего класса.
    Виртуальная функция - это такая функция, что решение какую версию выбрать принимается в runtime а не в compile time 


6. Memory layout of polymorphic objects
    struct Base{
        virtual void f() {}
    }; 
    sizeof(Base) == 8;
    Потому что у нас есть виртуальная функция, значит есть указатель на vtable
    
    vtable: структура данных, хранящаяся в статической памяти, одна на тип, в которой перечислены адреса виртуальных функций этого типа
    В ней хранятся адреса виртуальных предков и адреса виртуальных методов.


    vtable для base: хранится &Base::type_info и &Base::f



